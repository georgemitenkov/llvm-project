; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -instcombine -S                         | FileCheck %s
; RUN: opt < %s -instcombine -S -data-layout=n32        | FileCheck %s
; RUN: opt < %s -instcombine -S -data-layout=n32:64     | FileCheck %s
; RUN: opt < %s -instcombine -S -data-layout=n32:64:128 | FileCheck %s

declare void @llvm.memcpy.p0b8.p0b8.i32(b8* nocapture, b8* nocapture, i32, i1) nounwind

; memcpy can be expanded inline with load/store (based on the datalayout?)

define void @copy_1_byte(b8* %d, b8* %s) {
; CHECK-LABEL: @copy_1_byte(
; CHECK-NEXT:    [[TMP1:%.*]] = load b8, b8* [[S:%.*]], align 1
; CHECK-NEXT:    store b8 [[TMP1]], b8* [[D:%.*]], align 1
; CHECK-NEXT:    ret void
;
  call void @llvm.memcpy.p0b8.p0b8.i32(b8* %d, b8* %s, i32 1, i1 false)
  ret void
}

define void @copy_2_bytes(b8* %d, b8* %s) {
; CHECK-LABEL: @copy_2_bytes(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast b8* [[S:%.*]] to b16*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast b8* [[D:%.*]] to b16*
; CHECK-NEXT:    [[TMP3:%.*]] = load b16, b16* [[TMP1]], align 1
; CHECK-NEXT:    store b16 [[TMP3]], b16* [[TMP2]], align 1
; CHECK-NEXT:    ret void
;
  call void @llvm.memcpy.p0b8.p0b8.i32(b8* %d, b8* %s, i32 2, i1 false)
  ret void
}

; We don't expand small non-power-of-2. Should we? Might be a target-dependent choice.

define void @copy_3_bytes(b8* %d, b8* %s) {
; CHECK-LABEL: @copy_3_bytes(
; CHECK-NEXT:    call void @llvm.memcpy.p0b8.p0b8.i32(b8* noundef nonnull align 1 dereferenceable(3) [[D:%.*]], b8* noundef nonnull align 1 dereferenceable(3) [[S:%.*]], i32 3, i1 false)
; CHECK-NEXT:    ret void
;
  call void @llvm.memcpy.p0b8.p0b8.i32(b8* %d, b8* %s, i32 3, i1 false)
  ret void
}

define void @copy_4_bytes(b8* %d, b8* %s) {
; CHECK-LABEL: @copy_4_bytes(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast b8* [[S:%.*]] to b32*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast b8* [[D:%.*]] to b32*
; CHECK-NEXT:    [[TMP3:%.*]] = load b32, b32* [[TMP1]], align 1
; CHECK-NEXT:    store b32 [[TMP3]], b32* [[TMP2]], align 1
; CHECK-NEXT:    ret void
;
  call void @llvm.memcpy.p0b8.p0b8.i32(b8* %d, b8* %s, i32 4, i1 false)
  ret void
}

; We don't expand small non-power-of-2. Should we? Might be a target-dependent choice.

define void @copy_5_bytes(b8* %d, b8* %s) {
; CHECK-LABEL: @copy_5_bytes(
; CHECK-NEXT:    call void @llvm.memcpy.p0b8.p0b8.i32(b8* noundef nonnull align 1 dereferenceable(5) [[D:%.*]], b8* noundef nonnull align 1 dereferenceable(5) [[S:%.*]], i32 5, i1 false)
; CHECK-NEXT:    ret void
;
  call void @llvm.memcpy.p0b8.p0b8.i32(b8* %d, b8* %s, i32 5, i1 false)
  ret void
}

define void @copy_8_bytes(b8* %d, b8* %s) {
; CHECK-LABEL: @copy_8_bytes(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast b8* [[S:%.*]] to b64*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast b8* [[D:%.*]] to b64*
; CHECK-NEXT:    [[TMP3:%.*]] = load b64, b64* [[TMP1]], align 1
; CHECK-NEXT:    store b64 [[TMP3]], b64* [[TMP2]], align 1
; CHECK-NEXT:    ret void
;
  call void @llvm.memcpy.p0b8.p0b8.i32(b8* %d, b8* %s, i32 8, i1 false)
  ret void
}

define void @copy_16_bytes(b8* %d, b8* %s) {
; CHECK-LABEL: @copy_16_bytes(
; CHECK-NEXT:    call void @llvm.memcpy.p0b8.p0b8.i32(b8* noundef nonnull align 1 dereferenceable(16) [[D:%.*]], b8* noundef nonnull align 1 dereferenceable(16) [[S:%.*]], i32 16, i1 false)
; CHECK-NEXT:    ret void
;
  call void @llvm.memcpy.p0b8.p0b8.i32(b8* %d, b8* %s, i32 16, i1 false)
  ret void
}

