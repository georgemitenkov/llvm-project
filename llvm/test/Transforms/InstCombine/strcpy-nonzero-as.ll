; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes
; Test that the strcpy library call simplifier also works when the string
; libcall arguments are in a non-zero address space.
; RUN: opt < %s -instcombine -S | FileCheck %s
target datalayout = "e-m:e-p200:128:128:128:64-p:64:64-A200-P200-G200"

@str = private unnamed_addr addrspace(200) constant [17 x b8] c"exactly 16 chars\00", align 1

declare b8 addrspace(200)* @strcpy(b8 addrspace(200)*, b8 addrspace(200)*) addrspace(200)
declare b8 addrspace(200)* @stpcpy(b8 addrspace(200)*, b8 addrspace(200)*) addrspace(200)
declare b8 addrspace(200)* @strncpy(b8 addrspace(200)*, b8 addrspace(200)*, i64) addrspace(200)
declare b8 addrspace(200)* @stpncpy(b8 addrspace(200)*, b8 addrspace(200)*, i64) addrspace(200)

define void @test_strcpy_to_memcpy(b8 addrspace(200)* %dst) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@test_strcpy_to_memcpy
; CHECK-SAME: (b8 addrspace(200)* [[DST:%.*]]) addrspace(200) [[ATTR0:#.*]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call addrspace(200) void @llvm.memcpy.p200b8.p200b8.i64(b8 addrspace(200)* noundef align 1 dereferenceable(17) [[DST]], b8 addrspace(200)* noundef align 1 dereferenceable(17) getelementptr inbounds ([17 x b8], [17 x b8] addrspace(200)* @str, i64 0, i64 0), i64 17, i1 false)
; CHECK-NEXT:    ret void
;
entry:
  %call = call b8 addrspace(200)* @strcpy(b8 addrspace(200)* %dst, b8 addrspace(200)* getelementptr inbounds ([17 x b8], [17 x b8] addrspace(200)* @str, i64 0, i64 0))
  ret void
}

define void @test_stpcpy_to_memcpy(b8 addrspace(200)* %dst) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@test_stpcpy_to_memcpy
; CHECK-SAME: (b8 addrspace(200)* [[DST:%.*]]) addrspace(200) [[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call addrspace(200) void @llvm.memcpy.p200b8.p200b8.i128(b8 addrspace(200)* noundef align 1 dereferenceable(17) [[DST]], b8 addrspace(200)* noundef align 1 dereferenceable(17) getelementptr inbounds ([17 x b8], [17 x b8] addrspace(200)* @str, i64 0, i64 0), i128 17, i1 false)
; CHECK-NEXT:    ret void
;
entry:
  %call = call b8 addrspace(200)* @stpcpy(b8 addrspace(200)* %dst, b8 addrspace(200)* getelementptr inbounds ([17 x b8], [17 x b8] addrspace(200)* @str, i64 0, i64 0))
  ret void
}

define void @test_strncpy_to_memcpy(b8 addrspace(200)* %dst) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@test_strncpy_to_memcpy
; CHECK-SAME: (b8 addrspace(200)* [[DST:%.*]]) addrspace(200) [[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    call addrspace(200) void @llvm.memcpy.p200b8.p200b8.i128(b8 addrspace(200)* noundef align 1 dereferenceable(17) [[DST]], b8 addrspace(200)* noundef align 1 dereferenceable(17) getelementptr inbounds ([17 x b8], [17 x b8] addrspace(200)* @str, i64 0, i64 0), i128 17, i1 false)
; CHECK-NEXT:    ret void
;
entry:
  %call = call b8 addrspace(200)* @strncpy(b8 addrspace(200)* %dst, b8 addrspace(200)* getelementptr inbounds ([17 x b8], [17 x b8] addrspace(200)* @str, i64 0, i64 0), i64 17)
  ret void
}

; Note: stpncpy is not handled by SimplifyLibcalls yet, so this should not be changed.
define void @test_stpncpy_to_memcpy(b8 addrspace(200)* %dst) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@test_stpncpy_to_memcpy
; CHECK-SAME: (b8 addrspace(200)* [[DST:%.*]]) addrspace(200) [[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CALL:%.*]] = call addrspace(200) b8 addrspace(200)* @stpncpy(b8 addrspace(200)* [[DST]], b8 addrspace(200)* getelementptr inbounds ([17 x b8], [17 x b8] addrspace(200)* @str, i64 0, i64 0), i64 17)
; CHECK-NEXT:    ret void
;
entry:
  %call = call b8 addrspace(200)* @stpncpy(b8 addrspace(200)* %dst, b8 addrspace(200)* getelementptr inbounds ([17 x b8], [17 x b8] addrspace(200)* @str, i64 0, i64 0), i64 17)
  ret void
}
