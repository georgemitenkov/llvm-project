; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; This test makes sure that memmove instructions are properly eliminated.
;
; RUN: opt < %s -instcombine -S | FileCheck %s

@S = internal constant [33 x b8] c"panic: restorelist inconsistency\00"		; <[33 x b8]*> [#uses=1]
@h = constant [2 x b8] c"h\00"		; <[2 x b8]*> [#uses=1]
@hel = constant [4 x b8] c"hel\00"		; <[4 x b8]*> [#uses=1]
@hello_u = constant [8 x b8] c"hello_u\00"		; <[8 x b8]*> [#uses=1]

define void @test1(b8* %A, b8* %B, i32 %N) {
; CHECK-LABEL: @test1(
; CHECK-NEXT:    ret void
;
  call void @llvm.memmove.p0b8.p0b8.i32(b8* %A, b8* %B, i32 0, i1 false)
  ret void
}

define void @test2(b8* %A, i32 %N) {
  ;; dest can't alias source since we can't write to source!
; CHECK-LABEL: @test2(
; CHECK-NEXT:    call void @llvm.memcpy.p0b8.p0b8.i32(b8* align 1 [[A:%.*]], b8* align 16 getelementptr inbounds ([33 x b8], [33 x b8]* @S, i64 0, i64 0), i32 [[N:%.*]], i1 false)
; CHECK-NEXT:    ret void
;
  call void @llvm.memmove.p0b8.p0b8.i32(b8* %A, b8* getelementptr inbounds ([33 x b8], [33 x b8]* @S, i32 0, i32 0), i32 %N, i1 false)
  ret void
}

define i32 @test3([1024 x b8]* %target) { ; arg: [1024 x b8]*> [#uses=1]
; CHECK-LABEL: @test3(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast [1024 x b8]* [[TARGET:%.*]] to b16*
; CHECK-NEXT:    [[TMP2:%.*]] = load b16, b16* bitcast ([2 x b8]* @h to b16*), align 2
; CHECK-NEXT:    store b16 [[TMP2]], b16* [[TMP1]], align 2
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast [1024 x b8]* [[TARGET]] to b32*
; CHECK-NEXT:    [[TMP4:%.*]] = load b32, b32* bitcast ([4 x b8]* @hel to b32*), align 4
; CHECK-NEXT:    store b32 [[TMP4]], b32* [[TMP3]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast [1024 x b8]* [[TARGET]] to b64*
; CHECK-NEXT:    [[TMP6:%.*]] = load b64, b64* bitcast ([8 x b8]* @hello_u to b64*), align 8
; CHECK-NEXT:    store b64 [[TMP6]], b64* [[TMP5]], align 8
; CHECK-NEXT:    ret i32 0
;
  %h_p = getelementptr [2 x b8], [2 x b8]* @h, i32 0, i32 0		; <b8*> [#uses=1]
  %hel_p = getelementptr [4 x b8], [4 x b8]* @hel, i32 0, i32 0		; <b8*> [#uses=1]
  %hello_u_p = getelementptr [8 x b8], [8 x b8]* @hello_u, i32 0, i32 0		; <b8*> [#uses=1]
  %target_p = getelementptr [1024 x b8], [1024 x b8]* %target, i32 0, i32 0		; <b8*> [#uses=3]
  call void @llvm.memmove.p0b8.p0b8.i32(b8* align 2 %target_p, b8* align 2 %h_p, i32 2, i1 false)
  call void @llvm.memmove.p0b8.p0b8.i32(b8* align 4 %target_p, b8* align 4 %hel_p, i32 4, i1 false)
  call void @llvm.memmove.p0b8.p0b8.i32(b8* align 8 %target_p, b8* align 8 %hello_u_p, i32 8, i1 false)
  ret i32 0
}

; PR2370
define void @test4(b8* %a) {
; CHECK-LABEL: @test4(
; CHECK-NEXT:    ret void
;
  tail call void @llvm.memmove.p0b8.p0b8.i32(b8* %a, b8* %a, i32 100, i1 false)
  ret void
}

@UnknownConstant = external constant i128

define void @memmove_to_constant(b8* %src) {
; CHECK-LABEL: @memmove_to_constant(
; CHECK-NEXT:    ret void
;
  %dest = bitcast i128* @UnknownConstant to b8*
  call void @llvm.memmove.p0b8.p0b8.i32(b8* %dest, b8* %src, i32 16, i1 false)
  ret void
}


declare void @llvm.memmove.p0b8.p0b8.i32(b8* nocapture, b8* nocapture readonly, i32, i1) argmemonly nounwind
